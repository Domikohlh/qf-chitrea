#Import library
#Install all the libraries with 'pip install (Library)'

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import os
from sklearn.model_selection import train_test_split, StratifiedKFold
from sklearn.metrics import confusion_matrix, precision_score, recall_score, mean_squared_error, accuracy_score, mean_absolute_error, r2_score
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import RidgeCV, Lasso, LinearRegression, Ridge
from sklearn.ensemble import RandomForestRegressor
from sklearn.ensemble import VotingClassifier
from sklearn.svm import SVR
from rds2py import read_rds
from itertools import combinations

#Import processed data
data = read_rds(r"C:\Users\Alan\OneDrive\桌面\利率债择时模型\cleaned_macro_data.rds")
print(data.head())

# generate all variable combinations from the top ten relevant variables

top_vars = [
    "中国:社会消费品零售总额:当月值", "中国:M1:单位活期存款", "中国:M2", "中国:产量:发电量:当月值.1",
    "中国:M1", "中国:金融机构:企业存款余额", "中国:金融机构:短期贷款余额",
    "中国:城镇居民平均每百户拥有量:家用汽车", "中国:M0", "中国:产量:发电量:当月值"
]

# Try combinations of 3 to 6 variables (can adjust)
combi_list = []
for r in range(3, 7):
    combi_list.extend(combinations(top_vars, r))

# model loop for each combination

results = []

for combi in combi_list:
    X = data[list(combi)]
    y = data["中债国债到期收益率_10年"]  # target
    
    # train/test split
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)
    
    model = Ridge()
    model.fit(X_train, y_train)
    pred = model.predict(X_test)
    
    # Evaluation metrics
    mse = mean_squared_error(y_test, pred)
    mae = mean_absolute_error(y_test, pred)
    r2 = r2_score(y_test, pred)
    
    # Save results
    results.append({
        "features": combi,
        "mse": mse,
        "mae": mae,
        "r2": r2,
    })

# sort by R2 (or lowest MSE if you prefer)
sorted_results = sorted(results, key=lambda x: -x["r2"])


# convert prediction to signal for portfolio simulation (optional)

# if your prediction is yield level: convert to +1/0/-1 signals
signal = np.sign(np.diff(pred))  # assumes yield change as signal
# simulate long/short bond portfolio (duration up/down)

# evaluate Trading Performance (Sharpe etc.)
# use the prediction to simulate a simple long/short strategy. Based on the singal
# Simple Sharpe Ratio calculation
bond_return_series = y_test.diff().fillna(0).values 
daily_returns = signal * bond_return_series  # assume bond_return_series is pre-computed
sharpe_ratio = np.mean(daily_returns) / np.std(daily_returns) * np.sqrt(252)  # annualized

print("Sharpe Ratio: ", sharpe_ratio)

# Plot the prediction vs actual yield
plt.figure(figsize=(10, 6))
plt.plot(y_test.index, y_test, label="Actual Yield", color='blue')
plt.plot(y_test.index, pred, label="Predicted Yield", color='red')
plt.title("Yield Prediction vs Actual")
plt.xlabel("Date")
plt.ylabel("Yield")
plt.legend()
plt.show()

# Save the best combination of features and their performance metrics
best_combination = sorted_results[0]
best_combination_df = pd.DataFrame([best_combination])
best_combination_df.to_csv("best_combination.csv", index=False)

# Save the model for the best combination (optional)
import joblib
best_model = Ridge()
X_best = data[list(best_combination["features"])]
best_model.fit(X_best, y)
joblib.dump(best_model, "best_model.pkl")

print("Best feature combination: ", best_combination["features"])
print("MSE: ", best_combination["mse"])
print("MAE: ", best_combination["mae"])
print("R2: ", best_combination["r2"])
