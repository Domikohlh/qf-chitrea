import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import subprocess
import sys
from sklearn.linear_model import Ridge, LinearRegression
from sklearn.model_selection import TimeSeriesSplit, GridSearchCV
from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import StandardScaler
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.stattools import adfuller
from prophet import Prophet
import yfinance as yf  # For benchmark data if needed
import warnings

warnings.filterwarnings('ignore')

# 1. Data Extraction

# Load your data
yield_data = pd.read_excel(r"C:\Users\Alan\OneDrive\桌面\利率债择时模型\中国_中债国债到期收益率_10年.xlsx")
benchmark_data = pd.read_excel(r"C:\Users\Alan\OneDrive\桌面\利率债择时模型\中债国债总净价指数.xlsx")
macro_rds = pyreadr.read_r(r"C:\Users\Alan\OneDrive\桌面\利率债择时模型\cleaned_macro_data.rds")
macro_df = list(macro_rds.values())[0]


# 2. Data Manipulation (refer to R code)


# 3. Creating the Target Column 
# the top ten most relevant variables
top_vars = [
    "中国:社会消费品零售总额:当月值", "中国:M1:单位活期存款", "中国:M2", "中国:产量:发电量:当月值.1",
    "中国:M1", "中国:金融机构:企业存款余额", "中国:金融机构:短期贷款余额",
    "中国:城镇居民平均每百户拥有量:家用汽车", "中国:M0", "中国:产量:发电量:当月值"
]

# Benchmarking Cumulative Return Calculation
benchmark_yield = pd.read_excel("中国_中债国债到期收益率_10年.xlsx")
benchmark_yield.columns = ["date", "yield_10y"]
benchmark_yield["date"] = pd.to_datetime(benchmark_yield["date"])
benchmark_yield = benchmark_yield.sort_values("date").dropna()

benchmark_yield["log_return"] = np.log1p(benchmark_yield["yield_10y"] / 100)
benchmark_yield["cumulative_return"] = benchmark_yield["log_return"].cumsum()
print(benchmark_yield[["date", "yield_10y", "cumulative_return"]].tail())



# 3. Machine Learning Output - Model Selection
# LightGBM
lgb_model = lgb.LGBMRegressor()
lgb_model.fit(X_train, y_train)
lgb_preds = lgb_model.predict(X_test)
print("LightGBM MSE:", mean_squared_error(y_test, lgb_preds))

# XGBoost
xgb_model = xgb.XGBRegressor(objective="reg:squarederror")
xgb_model.fit(X_train, y_train)
xgb_preds = xgb_model.predict(X_test)
print("XGBoost MSE:", mean_squared_error(y_test, xgb_preds))

# LazyPredict Comparison
lazy = LazyRegressor(verbose=0, ignore_warnings=True, custom_metric=None)
models, predictions = lazy.fit(X_train, X_test, y_train, y_test)
print(models)

# 4. Backtesting
# === Rolling Out-of-Sample Backtest ===
def rolling_backtest(data, variables, model_class, window=60):
    excess_returns, mse_list = [], []
    for start in range(len(data) - window):
        train = data.iloc[start:start + window]
        test = data.iloc[start + window:start + window + 1]
        if test.empty: continue

        X_train, y_train = train[variables], train["yield_10y"]
        X_test, y_test = test[variables], test["yield_10y"].values[0]
        benchmark_test = test["benchmark"].values[0]

        model = model_class()
        model.fit(X_train, y_train)
        pred = model.predict(X_test)[0]

        excess_returns.append(pred - benchmark_test)
        mse_list.append((pred - y_test) ** 2)

    if len(excess_returns) < 2: return None, None
    return np.mean(excess_returns) / np.std(excess_returns), np.mean(mse_list)

# === Prophet Forecasting ===
def run_prophet(df):
    prophet_df = df[["date", "yield_10y"]].rename(columns={"date": "ds", "yield_10y": "y"})
    model = Prophet()
    model.fit(prophet_df)
    future = model.make_future_dataframe(periods=12, freq='M')
    forecast = model.predict(future)
    return forecast[["ds", "yhat"]]

# === LSTM Forecasting ===
def run_lstm(df, variables):
    sequence_length = 12
    df_lstm = df[variables + ["yield_10y"]].values

    X, y = [], []
    for i in range(len(df_lstm) - sequence_length):
        X.append(df_lstm[i:i + sequence_length, :-1])
        y.append(df_lstm[i + sequence_length, -1])

    X, y = np.array(X), np.array(y)
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

    model = Sequential()
    model.add(LSTM(50, input_shape=(X.shape[1], X.shape[2])))
    model.add(Dense(1))
    model.compile(loss='mse', optimizer='adam')
    model.fit(X_train, y_train, epochs=50, batch_size=16, verbose=0)

    predictions = model.predict(X_test)
    return predictions, y_test

# === Run Ridge/Lasso on Top Combos ===
top_combos = list(combinations(top_vars, 4))[:3]  # test top 3 sets
for model_class in [Ridge, Lasso]:
    for vars_ in top_combos:
        sr, mse = rolling_backtest(data_filtered, vars_, model_class)
        print(f"{model_class.__name__} {vars_}\nSharpe: {sr:.4f}, MSE: {mse:.4f}\n")

# === Run Prophet ===
prophet_output = run_prophet(data_filtered)
print(prophet_output.tail())

# === Run LSTM ===
lstm_vars = top_vars[:5]
preds, actuals = run_lstm(data_filtered, lstm_vars)
print("LSTM Test MSE:", mean_squared_error(actuals, preds))

